<!DOCTYPE html>
<html lang="en-us">
  <head>
    <title>
The Reactive Machine | Activities
</title>
    
<link rel="stylesheet" href="/css/style.af54df87ff3bd3c2c433dbfd4c3a7ecb417849c15384eba8e9fb6f7b5a9de6e2.css">
<link rel="stylesheet" href="/css/syntax.de5a118cd688caecccb0905dc27fdf35ea42b86621e7f077f96723087430564e.css">
<link rel="shortcut icon" href="/img/logo-icon.png">

  </head>
  <body class="page has-navbar-fixed-top">
    <main class="main">
      

<nav class="navbar is-fixed-top">
  <div class="container">
    <div class="navbar-brand">
      <a class="navbar-item" href="http://reactive-machine.org">
        <img src="/img/logo-icon.png">
      </a>

      <a class="navbar-item has-text-primary has-text-weight-bold" href="http://reactive-machine.org">
        Reactive Machine
      </a>

      <a role="button" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="navbar-menu">
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
      </a>
    </div>

    <div id="navbar-menu" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="/docs">
          Docs
        </a>
        <a class="navbar-item" href="https://github.com/Microsoft/ReactiveMachine">
          GitHub
        </a>
      </div>
    </div>
  </div>
</nav>


      
<section class="hero is-primary">
  <div class="hero-body">
    <div class="container">
      <p class="title is-size-1 is-size-2-mobile has-text-weight-light is-spaced">
        Activities
      </p>
      <p class="subtitle is-size-3 is-size-4-mobile has-text-weight-light">
        encapsulate nondeterminism and external interactions
      </p>
    </div>
  </div>
</section>
  

<nav class="tabs">
  <div class="container">

    <ul> 
          <li>
            <a href="/docs/">
              Overview
            </a>
          </li> 
          <li class="is-active">
            <a href="/docs/model/">
              Programming Model
            </a>
          </li> 
          <li>
            <a href="/docs/hosts/">
              Hosts
            </a>
          </li> 
          <li>
            <a href="/docs/examples/">
              Examples
            </a>
          </li> 
          <li>
            <a href="/docs/motivation/">
              Motivation
            </a>
          </li>
    </ul>
  </div>
</nav>



    
       
      
          <nav class="tabs" style="margin-top: -25px;">
            <div class="container">
              <ul>
        
                <li class="">
                    <a href="/docs/model-orchestrations/">Orchestrations</a>
                </li>
        
                <li class="is-active">
                    <a href="/docs/model-activities/">Activities</a>
                </li>
        
                <li class="">
                    <a href="/docs/model-affinities/">Affinities</a>
                </li>
        
                <li class="">
                    <a href="/docs/model-states/">States</a>
                </li>
        
                <li class="">
                    <a href="/docs/model-events/">Events</a>
                </li>
        
              </ul>
            </div>
          </nav>
      
    

    
       
      
    

    
       
      
    


<div class="container docs-container">
  <div class="content">
    

<p>Activities define how to execute some task, given some input, and return some value. The runtime logs all activity results, so the outcome is deterministically replayable even if the activity code is nondeterministic and/or performs arbitrary I/O.</p>

<p>Activities are declared as a C# class that implements the <code>IAtLeastOnceActivity&lt;TResult&gt;</code> or <code>IAtMostOnceActivity&lt;TResult&gt;</code> interface. They implement an <code>Execute</code> method that gets called with an <code>IActivityContext</code> argument and returns a <code>TResult</code>.</p>

<h3 id="example-1-calling-an-external-service">Example 1 : Calling an External Service</h3>

<p>We can define an activity that reads the contents of a blob from Azure Storage:</p>
<div class="highlight"><pre class="chroma"><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="k">class</span> <span class="nc">ReadBlob</span> <span class="p">:</span> <span class="n">IAtLeastOnceActivity</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="c1">// the input to the activity
</span><span class="c1"></span>    <span class="k">public</span> <span class="kt">string</span> <span class="n">Path</span><span class="p">;</span>

    <span class="c1">// must specify a time limit
</span><span class="c1"></span>    <span class="k">public</span> <span class="n">TimeSpan</span> <span class="n">TimeLimit</span> <span class="p">=&gt;</span> <span class="n">TimeSpan</span><span class="p">.</span><span class="n">FromSeconds</span><span class="p">(</span><span class="m">30</span><span class="p">);</span>

    <span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">Execute</span><span class="p">(</span><span class="n">IContext</span> <span class="n">context</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">context</span><span class="p">.</span><span class="n">Logger</span><span class="p">.</span><span class="n">LogInformation</span><span class="p">(</span><span class="s">&#34;Reading From Storage&#34;</span><span class="p">);</span>
        <span class="n">CloudBlockBlob</span> <span class="n">blobReference</span> <span class="p">=</span> <span class="n">Utils</span><span class="p">.</span><span class="n">GetAzureBlob</span><span class="p">(</span><span class="n">Path</span><span class="p">);</span>
        <span class="kt">var</span> <span class="n">content</span> <span class="p">=</span> <span class="k">await</span> <span class="n">blobReference</span><span class="p">.</span><span class="n">DownloadTextAsync</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">content</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p><strong>Timeouts</strong>. Activities must specify a TimeLimit property. A timer is automatically started when the activity starts executing. If the activity does not finish before the time limit is reached, a <code>System.TimeoutException</code> is thrown. In general, using timeouts is helpful to guarantee that orchestrations can make progress.</p>

<p><strong>Context object</strong>. Just like for orchestrations, the <code>Execute</code> method is passed a context. However, this context has a lot fewer methods. Essentially, it just supports logging (via <code>context.Logger</code>) and accessing configuration information (via <code>context.GetConfiguration&lt;TConfiguration&gt;()</code>).</p>

<h2 id="guidelines">Guidelines</h2>

<p>Activities &ldquo;determinize&rdquo; nondeterministic, external, fallible, or otherwise unpredictable tasks, by logging the outcome. Under replay, activities are not repeated if the log has already recorded a result (a returned value or exception) for this activity: instead, the recorded result is used. Thus, the activity has become <em>deterministically replayable</em>.</p>

<p>Activities also provide parallelism: they always run on the .NET thread pool, and are therefore appropriate for long-running CPU-intensive tasks.</p>

<h3 id="activites-vs-orchestrations">Activites vs. Orchestrations</h3>

<p>Activities complement orchestrations in terms of what you are allowed to do inside <code>Execute</code>:</p>

<table>
<thead>
<tr>
<th></th>
<th>Activity</th>
<th>Orchestration</th>
</tr>
</thead>

<tbody>
<tr>
<td>Nondeterminism</td>
<td>✓</td>
<td>❌</td>
</tr>

<tr>
<td>External Calls</td>
<td>✓</td>
<td>❌</td>
</tr>

<tr>
<td>Any type of I/O</td>
<td>✓</td>
<td>❌</td>
</tr>

<tr>
<td>Long-running computations</td>
<td>✓</td>
<td>❌</td>
</tr>

<tr>
<td>Perform an operation</td>
<td>❌</td>
<td>✓</td>
</tr>

<tr>
<td>Fork an operation</td>
<td>❌</td>
<td>✓</td>
</tr>

<tr>
<td>Schedule an operation</td>
<td>❌</td>
<td>✓</td>
</tr>
</tbody>
</table>

<h3 id="example-2-performing-a-cpu-intensive-computation">Example 2: Performing a CPU-intensive computation</h3>

<p>In the <code>Applications/Miner.Service</code> project, we demonstrate a hash-space mining application.  Searching for a hash collision is CPU intensive, so we use an orchestration to break the search space into small portions, and then run an activity for searching each portion. The runtime runs each portion on the thread pool.</p>
<div class="highlight"><pre class="chroma"><code class="language-c#" data-lang="c#"><span class="k">namespace</span> <span class="nn">Miner.Service</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">class</span> <span class="nc">SearchPortion</span> <span class="p">:</span> <span class="n">IAtLeastOnceActivity</span><span class="p">&lt;</span><span class="n">List</span><span class="p">&lt;</span><span class="kt">long</span><span class="p">&gt;&gt;</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="n">TimeSpan</span> <span class="n">TimeLimit</span> <span class="p">=&gt;</span> <span class="n">TimeSpan</span><span class="p">.</span><span class="n">FromSeconds</span><span class="p">(</span><span class="m">30</span><span class="p">);</span>
 
        <span class="k">public</span> <span class="kt">int</span> <span class="n">Target</span><span class="p">;</span>
        <span class="k">public</span> <span class="kt">long</span> <span class="n">Start</span><span class="p">;</span>
        <span class="k">public</span> <span class="kt">long</span> <span class="n">Count</span><span class="p">;</span>

        <span class="k">public</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">List</span><span class="p">&lt;</span><span class="kt">long</span><span class="p">&gt;&gt;</span> <span class="n">Execute</span><span class="p">(</span><span class="n">IContext</span> <span class="n">context</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">context</span><span class="p">.</span><span class="n">Logger</span><span class="p">.</span><span class="n">LogInformation</span><span class="p">(</span><span class="s">$&#34;Starting portion [{Start},{Start + Count})&#34;</span><span class="p">);</span>
            <span class="kt">var</span> <span class="n">results</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">long</span><span class="p">&gt;();</span>
            <span class="c1">// search given range for a hash collision
</span><span class="c1"></span>            <span class="k">for</span> <span class="p">(</span><span class="kt">var</span> <span class="n">i</span> <span class="p">=</span> <span class="n">Start</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">Start</span> <span class="p">+</span> <span class="n">Count</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">GetHashCode</span><span class="p">()</span> <span class="p">==</span> <span class="n">Target</span><span class="p">)</span>
                    <span class="n">results</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">context</span><span class="p">.</span><span class="n">Logger</span><span class="p">.</span><span class="n">LogInformation</span><span class="p">(</span><span class="s">$&#34;Finished portion [{Start},{Start + Count})&#34;</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">Task</span><span class="p">.</span><span class="n">FromResult</span><span class="p">(</span><span class="n">results</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<h3 id="at-least-once-vs-at-most-once">At-least-once vs. At-most-once</h3>

<p>If a host recovers after failing while executing an activity, the system detects in the log that the activity did not complete. However, it is not possible to know how far the activity progressed before the failure; it may have already achieved its objective, or it may have failed before the activity even got really started. The right thing to do in this case may depend on the specific purpose of the activity, i.e. it is application-dependent.</p>

<p>In most cases, the right thing to do is to simply restart the activity, at the risk of executing it a second time. By using the interface <code>IAtLeastOnceActivity&lt;string&gt;</code>, we indicate to the runtime that this is always the desired course of action.</p>

<p>Sometimes, it is desirable to take some special action rather than just restarting an activity. The interface <code>IAtMostOnceActivity&lt;TReturn&gt;</code> can be used for that:</p>
<div class="highlight"><pre class="chroma"><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="k">class</span> <span class="nc">MyActivity</span> <span class="p">:</span> <span class="n">IAtMostOnceActivity</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">Execute</span><span class="p">(</span><span class="n">IContext</span> <span class="n">context</span><span class="p">)</span>
    <span class="p">{</span>
       <span class="p">...</span> <span class="c1">// regular execution
</span><span class="c1"></span>    <span class="p">}</span>
    
    <span class="k">public</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">TReturn</span><span class="p">&gt;</span> <span class="n">AfterFault</span><span class="p">(</span><span class="n">IContext</span> <span class="n">context</span><span class="p">)</span>
    <span class="p">{</span>
         <span class="p">...</span> <span class="c1">// custom handling
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>The <code>AfterFault</code> handler is called when the runtime, during recovery, detects that this activity may have been previously executed but did not complete. Inside the handler, we can take an appropriate action to deal with this situation. For example, we can perform some tests to figure out if the desired effect of the activity (e.g. creating a blob) has already taken place (i.e. the blob already exists), and re-execute it only if those tests indicate so.</p>

<p>Conceptually, the <code>AfterFault</code> handler provides us with a mechanism that can wrap external calls that are not idempotent or not exactly idempotent into a truly idempotent activity.</p>

  </div>
</div>


    </main>

    
<footer class="footer has-background-dark">
  <div class="container has-text-centered">
    <p class="is-size-5 is-size-6-mobile has-text-white-bis">
      &copy; 2019 Microsoft Corporation
    </p>
  </div>
</footer>

    <script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
<script src="/js/app.min.e119cad0205945173c83cdb2ffec7a581007a612e088c70bd62c7245ad7e58cb.js" integrity=""></script>

  </body>
</html>
