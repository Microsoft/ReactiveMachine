<!DOCTYPE html>
<html lang="en-us">
  <head>
    <title>
The Reactive Machine | Affinities
</title>
    
<link rel="stylesheet" href="/ReactiveMachine/css/style.af54df87ff3bd3c2c433dbfd4c3a7ecb417849c15384eba8e9fb6f7b5a9de6e2.css">
<link rel="stylesheet" href="/ReactiveMachine/css/syntax.de5a118cd688caecccb0905dc27fdf35ea42b86621e7f077f96723087430564e.css">
<link rel="shortcut icon" href="/ReactiveMachine/img/logo-icon.png">

  </head>
  <body class="page has-navbar-fixed-top">
    <main class="main">
      

<nav class="navbar is-fixed-top">
  <div class="container">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://microsoft.github.io/ReactiveMachine">
        <img src="/ReactiveMachine/img/logo-icon.png">
      </a>

      <a class="navbar-item has-text-primary has-text-weight-bold" href="https://microsoft.github.io/ReactiveMachine">
        Reactive Machine
      </a>

      <a role="button" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="navbar-menu">
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
      </a>
    </div>

    <div id="navbar-menu" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="/ReactiveMachine/docs">
          Docs
        </a>
        <a class="navbar-item" href="https://github.com/Microsoft/ReactiveMachine">
          GitHub
        </a>
      </div>
    </div>
  </div>
</nav>


      
<section class="hero is-primary">
  <div class="hero-body">
    <div class="container">
      <p class="title is-size-1 is-size-2-mobile has-text-weight-light is-spaced">
        Affinities
      </p>
      <p class="subtitle is-size-3 is-size-4-mobile has-text-weight-light">
        define partitions
      </p>
    </div>
  </div>
</section>
  

<nav class="tabs">
  <div class="container">

    <ul> 
          <li>
            <a href="/ReactiveMachine/docs/">
              Overview
            </a>
          </li> 
          <li class="is-active">
            <a href="/ReactiveMachine/docs/model/">
              Programming Model
            </a>
          </li> 
          <li>
            <a href="/ReactiveMachine/docs/hosts/">
              Hosts
            </a>
          </li> 
          <li>
            <a href="/ReactiveMachine/docs/examples/">
              Examples
            </a>
          </li> 
          <li>
            <a href="/ReactiveMachine/docs/motivation/">
              Motivation
            </a>
          </li>
    </ul>
  </div>
</nav>



    
       
      
          <nav class="tabs" style="margin-top: -25px;">
            <div class="container">
              <ul>
        
                <li class="">
                    <a href="/ReactiveMachine/docs/model-orchestrations/">Orchestrations</a>
                </li>
        
                <li class="">
                    <a href="/ReactiveMachine/docs/model-activities/">Activities</a>
                </li>
        
                <li class="is-active">
                    <a href="/ReactiveMachine/docs/model-affinities/">Affinities</a>
                </li>
        
                <li class="">
                    <a href="/ReactiveMachine/docs/model-states/">States</a>
                </li>
        
                <li class="">
                    <a href="/ReactiveMachine/docs/model-events/">Events</a>
                </li>
        
              </ul>
            </div>
          </nav>
      
    

    
       
      
    

    
       
      
    


<div class="container docs-container">
  <div class="content">
    

<p>Affinities are used to declare a partitioning scheme. Affinity partitions provide an abstract notion of locality. They have several important applications:</p>

<ol>
<li><p>Partitions allow state to be stored and accessed scalably, because they can be load-balanced automatically across multiple host machines. Partitions are identified by <strong>partition keys</strong>.</p></li>

<li><p>Partitions can be <strong>locked</strong>. This allows orchestrations to perform multiple read and update operations consistently, which is often important (yet nontrivial to implement without locks). For example:</p>

<ul>
<li><p>An orchestration can lock a partition to test if a state exists before creating it, without risking buggy races.</p></li>

<li><p>An orchestration can implement an atomic balance transfer between two accounts by locking both accounts, checking the available balance, and then updating the balance in both accounts.</p></li>
</ul></li>

<li><p>Partitions can be used to <strong>place</strong> orchestrations and activities. Judicious placement can improve performance. For example, if an orchestration accesses multiple states that reside in the same partition, then it is a good idea to place that orchestration on the same partition, because it reduces delay incurred when sending messages across the network.</p></li>
</ol>

<h2 id="declaring-affinities">Declaring Affinities</h2>

<p>There are two types of affinities. Both are declared as a C# interfaces.</p>

<p><strong>Singleton Affinities</strong> declare a single partition. These are appropriate for states that do not have a natural internal partitioning, and do not need to scale (in terms of memory or load) beyond what is easily provided by a single core on a single machine.</p>
<div class="highlight"><pre class="chroma"><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="k">interface</span> <span class="n">ICounterAffinity</span> <span class="p">:</span> <span class="n">ISingletonAffinity</span><span class="p">&lt;</span><span class="n">ICounterAffinity</span><span class="p">&gt;</span>
<span class="p">{</span>
<span class="p">}</span></code></pre></div>
<p>The interface must implement <code>ISingletonAffinity</code> with one generic type parameter which is the same as the interface being declared.</p>

<p><strong>Partitioned Affinities</strong> define a key name and type to be used for identifying partitions. It is best to pick keys that are naturally present in the application logic: for example, for state that represents user information, we can choose the unique user id to be the partition key. Or, for bank account information, we can use a unique Guid identifying the account.</p>
<div class="highlight"><pre class="chroma"><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="k">interface</span> <span class="n">IUserAffinity</span> <span class="p">:</span> <span class="n">IPartitionedAffinity</span><span class="p">&lt;</span><span class="n">IUserAffinity</span><span class="p">,</span> <span class="kt">string</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="kt">string</span> <span class="n">UserId</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="k">public</span> <span class="k">interface</span> <span class="n">IAccountAffinity</span> <span class="p">:</span> <span class="n">IPartitionedAffinity</span><span class="p">&lt;</span><span class="n">IAccountAffinity</span><span class="p">,</span><span class="n">Guid</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="n">Guid</span> <span class="n">AccountId</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>The interface must contain a single property with a getter. This property provides a name  for the partition key, and a type. The interface must implement <code>IPartitionedAffinity</code> with 2 generic type parameters, the first one being the same as the interface being declared, and the second one being the type of the partition key.</p>

<h2 id="implementing-affinities">Implementing Affinities</h2>

<p>The classes that define orchestrations, activities, read operations, update operations, or events can implement an affinity (or even multiple affinities). This means any object of that class becomes associated with one or more partitions. There are several reasons to associate objects with specific partitions:</p>

<ul>
<li><p>A read or update operation must be associated with the partition it is reading or updating.</p></li>

<li><p>An event must be associated with all the partitions that it is influencing, i.e. states that are subscribing to it.</p></li>

<li><p>An orchestration or activity that is associated with one or more partitions can lock them all prior to execution (the &ldquo;lock set&rdquo;).</p></li>

<li><p>An orchestration or activity associated with a single partition is executed on the same host as that partition, which can improve performance.</p></li>
</ul>

<h3 id="example-1-update-operation">Example 1: Update Operation</h3>

<p>Consider an update operation called <code>Deposit</code> that targets an account state that is partitioned by <code>IAccountAffinity</code>. To indicate which account is targeted, we implement the <code>IAccountAffinity</code> interface, by supplying a getter for the property <code>AccountId</code>. Therefore, any instance of this operation can be targeted at the correct account partition.</p>
<div class="highlight"><pre class="chroma"><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="k">class</span> <span class="nc">Deposit</span> <span class="p">:</span> 
    <span class="n">IUpdate</span><span class="p">&lt;</span><span class="n">AccountState</span><span class="p">,</span> <span class="n">UnitType</span><span class="p">&gt;,</span> 
    <span class="n">IAccountAffinity</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">Guid</span> <span class="n">AccountId</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Amount</span><span class="p">;</span>

    <span class="k">public</span> <span class="n">UnitType</span> <span class="n">Execute</span><span class="p">(</span><span class="n">IUpdateContext</span><span class="p">&lt;</span><span class="n">AccountState</span><span class="p">&gt;</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>  <span class="p">...</span>  <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<h3 id="example-2-event-targeting-multiple-partitions">Example 2: Event Targeting Multiple Partitions</h3>

<p>Consider an event representing a money transfer between two accounts, issued by some user. Conceivably, this event influences both account states (corresponding to source and destination) as well as a user state (corresponding to the initiator). As before, we can associate the object with a user by implementing IUserAffinity. However, for the accounts we need more than one: thus we implement <code>IMultiple&lt;AccountAffinity, Guid&gt;</code>, which allows us to enumerate the associated partition keys.</p>
<div class="highlight"><pre class="chroma"><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="k">class</span> <span class="nc">TransferEvent</span> <span class="p">:</span> 
    <span class="n">IEvent</span><span class="p">,</span>
    <span class="n">IUserAffinity</span><span class="p">,</span>
    <span class="n">IMultiple</span><span class="p">&lt;</span><span class="n">IAccountAffinity</span><span class="p">,</span> <span class="n">Guid</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">InitiatedBy</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">Guid</span> <span class="n">FromAccount</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">Guid</span> <span class="n">ToAccount</span><span class="p">;</span>

    <span class="k">public</span> <span class="n">UserId</span> <span class="p">=&gt;</span> <span class="n">InitiatedBy</span><span class="p">;</span>                   <span class="c1">// implements IUserAffinity
</span><span class="c1"></span>    <span class="k">public</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Guid</span><span class="p">&gt;</span> <span class="n">DeclareAffinities</span><span class="p">()</span>    <span class="c1">// implements IMultiple&lt;IAccountAffinity,Guid&gt;
</span><span class="c1"></span>    <span class="p">{</span>
        <span class="k">yield</span> <span class="k">return</span> <span class="n">FromAccount</span><span class="p">;</span>
        <span class="k">yield</span> <span class="k">return</span> <span class="n">ToAccount</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<h1 id="locked-execution">Locked Execution</h1>

<p>An orchestration or activity can use the <code>Locked</code> attribute on its Execute method to indicate that all the associated partitions should be locked prior to execution (and released afterwards).</p>

<h3 id="example-3-locked-orchestration">Example 3: Locked Orchestration</h3>

<p>If we need to check a condition before performing an orchestration, we can do so under a lock to prevent races. For example, we can check if an account exists before calling an orchestration that initializes it:</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="k">public</span> <span class="k">class</span> <span class="nc">CreateAccount</span> <span class="p">:</span> <span class="n">IOrchestration</span><span class="p">&lt;</span><span class="kt">bool</span><span class="p">&gt;,</span> <span class="n">IAccountAffinity</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">Guid</span> <span class="n">AccountId</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span><span class="na">
</span><span class="na">
</span><span class="na">    [Lock]</span>
    <span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">bool</span><span class="p">&gt;</span> <span class="n">Execute</span><span class="p">(</span><span class="n">IOrchestrationContext</span> <span class="n">context</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">exists</span> <span class="p">=</span> <span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="n">StateExists</span><span class="p">&lt;</span><span class="n">AccountState</span><span class="p">,</span> <span class="n">IAccountAffinity</span><span class="p">,</span> <span class="n">Guid</span><span class="p">&gt;(</span><span class="n">AccountId</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">exists</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">await</span> <span class="n">context</span><span class="p">.</span><span class="n">PerformOrchestration</span><span class="p">(</span><span class="k">new</span> <span class="n">CreateAccount</span><span class="p">()</span> <span class="p">{</span> <span class="n">AccountId</span> <span class="p">=</span> <span class="n">AccountId</span> <span class="p">});</span>
            <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>Note that for this type of situation, it is often more convenient to use an initializer orchestration, which can execute automatically when accessing a non-existent state. However, here we also want to return a boolean indicating whether the creation happened or not.</p>

<h3 id="example-4-locked-activities">Example 4: Locked Activities</h3>

<p>Consider activities that can read and write external cloud storage (e.g. blobs). By declaring them locked, we ensure that no concurrent read or writes can target the same path.</p>
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="k">public</span> <span class="k">interface</span> <span class="n">IPathAffinity</span> <span class="p">:</span> <span class="n">IPartitionedAffinity</span><span class="p">&lt;</span><span class="n">IPathAffinity</span><span class="p">,</span> <span class="kt">string</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="kt">string</span> <span class="n">Path</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">ReadBlob</span> <span class="p">:</span> <span class="n">IActivity</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;,</span> <span class="n">IPathAffinity</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Path</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span><span class="na">
</span><span class="na">
</span><span class="na">    [Lock]</span>
    <span class="k">public</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">Execute</span><span class="p">(</span><span class="n">IContext</span> <span class="n">context</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">context</span><span class="p">.</span><span class="n">Logger</span><span class="p">.</span><span class="n">LogInformation</span><span class="p">(</span><span class="s">$&#34;Reading From {Path}&#34;</span><span class="p">);</span>
        <span class="p">...</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">WriteBlob</span> <span class="p">:</span> <span class="n">IActivity</span><span class="p">&lt;</span><span class="n">UnitType</span><span class="p">&gt;,</span> <span class="n">IPathAffinity</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Path</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Content</span><span class="p">;</span><span class="na">
</span><span class="na">
</span><span class="na">    [Lock]</span>
    <span class="k">public</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">UnitType</span><span class="p">&gt;</span> <span class="n">Execute</span><span class="p">(</span><span class="n">IContext</span> <span class="n">context</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">context</span><span class="p">.</span><span class="n">Logger</span><span class="p">.</span><span class="n">LogInformation</span><span class="p">(</span><span class="s">$&#34;Writing {Content.Length} Characters to {Path}&#34;</span><span class="p">);</span>
        <span class="p">...</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>Note that this is a different method than using e-tags; here, storage conflicts are not just detected after the fact, but prevented before they happen. This is also called &ldquo;pessimistic&rdquo; concurrency control, as opposed to &ldquo;optimistic&rdquo; concurrency control.</p>

<h1 id="synchronization-rules">Synchronization Rules</h1>

<p>In most cases, locks are automatically acquired when performing an operation that requires locks. However, there are two exceptions:</p>

<ul>
<li>An orchestration cannot call a locked activity unless it already holds all associated locks.</li>
<li>An orchestration cannot call <code>IOrchestrationContext.StateExists</code> unless it already holds the associated lock.</li>
</ul>

<p>Also, there are additional rules that limit what you can do from within a locked orchestration. Essentially, they force orchestrations to acquire all the needed locks upfront. This ensures that no deadlocks can result from cyclic wait dependencies.</p>

<ul>
<li>A locked orchestration can perform a read or write operation only if it already holds the associated lock.</li>
<li>A locked orchestration can perform an event only if it already holds all associated locks.</li>
<li>A locked orchestration can perform a locked activity only if it already holds all associated locks.</li>
<li>A locked orchestration can perform a locked orchestration only if it already holds all associated locks.</li>
<li>A locked orchestration cannot perform an unlocked orchestration.</li>
<li>A locked orchestration can however always fork anything (as opposed to perform)</li>
</ul>

  </div>
</div>


    </main>

    
<footer class="footer has-background-dark">
  <div class="container has-text-centered">
    <p class="is-size-5 is-size-6-mobile has-text-white-bis">
      &copy; 2020 Microsoft Corporation
    </p>
  </div>
</footer>

    <script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
<script src="/ReactiveMachine/js/app.min.e119cad0205945173c83cdb2ffec7a581007a612e088c70bd62c7245ad7e58cb.js" integrity=""></script>

  </body>
</html>
